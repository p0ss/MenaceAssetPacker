# Getting Started: Your First Plugin

This guide walks through creating, building, and deploying a Menace SDK plugin
from scratch. By the end you will have a working modpack that queries game
objects, patches a method, modifies template data, and hooks up live debug
output in the developer console.

---

## Prerequisites

1. **MelonLoader** installed into the target game. The game's root directory
   should contain a `MelonLoader/` folder with `MelonLoader.dll`,
   `0Harmony.dll`, `Il2CppInterop.Runtime.dll`, and the generated
   `Il2CppAssemblies/` directory.

2. **Menace.ModpackLoader.dll** deployed as a MelonLoader mod (placed in the
   game's `Mods/` directory, or loaded by the Menace Modkit app).

3. **.NET 6 SDK** installed on your development machine (`dotnet --version`
   should report 6.x or later).

4. A text editor or IDE with C# support (Visual Studio, Rider, VS Code with
   C# Dev Kit, etc.).

---

## Modpack Structure

A modpack is a folder containing a `modpack.json` manifest and optional
subdirectories:

```
MyMod-modpack/
  modpack.json
  dlls/
    MyMod.dll          <-- your compiled plugin
  assets/
    ...                <-- replacement textures, audio, etc.
```

The loader discovers modpacks by scanning every subdirectory of the game's
`Mods/` folder for `modpack.json` files.

### Minimal modpack.json

```json
{
  "manifestVersion": 2,
  "name": "MyMod",
  "version": "1.0.0",
  "author": "YourName",
  "description": "A short description of what the mod does.",
  "loadOrder": 100,
  "patches": {},
  "assets": {},
  "code": {
    "sources": [],
    "references": [
      "MelonLoader",
      "0Harmony",
      "Il2CppInterop.Runtime",
      "Il2Cppmscorlib",
      "Assembly-CSharp",
      "Menace.ModpackLoader"
    ],
    "prebuiltDlls": []
  },
  "securityStatus": "SourceVerified"
}
```

Key fields:

- `manifestVersion` -- always `2` for current format.
- `loadOrder` -- lower numbers load first. Use 100 as default; use lower
  values if other mods depend on yours.
- `patches` -- data-driven template field overrides (see below). Can be empty
  if your mod is code-only.
- `code.references` -- assembly names the Modkit compiler needs when building
  from source. Not required if you ship prebuilt DLLs.
- `securityStatus` -- set to `"SourceVerified"` for mods whose source has
  been reviewed.

---

## Create the Project

```bash
mkdir MyMod && cd MyMod
dotnet new classlib -n MyMod --framework net6.0
cd MyMod
```

Edit `MyMod.csproj` to reference the SDK and game assemblies. All references
should be `Private=false` (copy-local disabled) because MelonLoader already
loads these at runtime:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <!-- Path to MelonLoader DLLs in the game directory -->
    <Reference Include="MelonLoader">
      <HintPath>$(GameDir)/MelonLoader/MelonLoader.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="0Harmony">
      <HintPath>$(GameDir)/MelonLoader/0Harmony.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="Il2CppInterop.Runtime">
      <HintPath>$(GameDir)/MelonLoader/Il2CppInterop.Runtime.dll</HintPath>
      <Private>false</Private>
    </Reference>

    <!-- IL2CPP proxy assemblies generated by MelonLoader -->
    <Reference Include="Il2Cppmscorlib">
      <HintPath>$(GameDir)/MelonLoader/Il2CppAssemblies/Il2Cppmscorlib.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="Assembly-CSharp">
      <HintPath>$(GameDir)/MelonLoader/Il2CppAssemblies/Assembly-CSharp.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="UnityEngine.CoreModule">
      <HintPath>$(GameDir)/MelonLoader/Il2CppAssemblies/UnityEngine.CoreModule.dll</HintPath>
      <Private>false</Private>
    </Reference>

    <!-- The Menace SDK itself -->
    <Reference Include="Menace.ModpackLoader">
      <HintPath>$(GameDir)/Mods/Menace.ModpackLoader.dll</HintPath>
      <Private>false</Private>
    </Reference>
  </ItemGroup>
</Project>
```

Replace `$(GameDir)` with the actual path to your game install, or define it
as an MSBuild property (`dotnet build -p:GameDir=/path/to/game`).

---

## Implement IModpackPlugin

Replace the generated `Class1.cs` with:

```csharp
using System.Reflection;
using MelonLoader;
using HarmonyLib;
using Menace.ModpackLoader;
using Menace.SDK;

namespace MyMod;

public class MyModPlugin : IModpackPlugin
{
    private MelonLogger.Instance _log;
    private Harmony _harmony;
    private bool _patchesApplied;

    // ---------------------------------------------------------------
    // Lifecycle
    // ---------------------------------------------------------------

    public void OnInitialize(MelonLogger.Instance logger, Harmony harmony)
    {
        _log = logger;
        _harmony = harmony;
        _log.Msg("MyMod v1.0.0 loaded");
    }

    public void OnSceneLoaded(int buildIndex, string sceneName)
    {
        _log.Msg($"Scene loaded: {sceneName}");

        // Apply patches once, after the game assembly is available
        if (!_patchesApplied)
        {
            ApplyPatches();
            _patchesApplied = true;
        }

        // Query live game objects
        QueryWeapons();

        // Modify template data
        ModifyTemplates();

        // Set up a debug watch
        SetupWatches();
    }

    // ---------------------------------------------------------------
    // Querying objects with GameQuery
    // ---------------------------------------------------------------

    private void QueryWeapons()
    {
        // Find all instances of a game type by name
        var weapons = GameQuery.FindAll("WeaponTemplate");
        _log.Msg($"Found {weapons.Length} weapon templates");

        foreach (var weapon in weapons)
        {
            if (weapon.IsNull) continue;

            // Read fields from IL2CPP memory by name
            string name   = weapon.GetName();
            int damage     = weapon.ReadInt("Damage");
            float range    = weapon.ReadFloat("Range");
            bool automatic = weapon.ReadBool("IsAutomatic");

            _log.Msg($"  {name}: damage={damage} range={range} auto={automatic}");
        }

        // Find a specific template by type and Unity object name
        var shotgun = GameQuery.FindByName("WeaponTemplate", "Shotgun");
        if (!shotgun.IsNull)
        {
            _log.Msg($"Shotgun damage: {shotgun.ReadInt("Damage")}");
        }
    }

    // ---------------------------------------------------------------
    // Reading and writing fields with GameObj
    // ---------------------------------------------------------------

    private void ReadNestedField(GameObj obj)
    {
        // Read a pointer field to get a child IL2CPP object
        GameObj statsObj = obj.ReadObj("Stats");
        if (!statsObj.IsNull)
        {
            int maxHp = statsObj.ReadInt("MaxHealth");
            _log.Msg($"MaxHealth = {maxHp}");
        }

        // Write a field directly in IL2CPP memory
        bool ok = obj.WriteInt("Damage", 999);
        if (!ok)
            _log.Warning("Failed to write Damage field");
    }

    // ---------------------------------------------------------------
    // Iterating collections with GameList, GameDict, GameArray
    // ---------------------------------------------------------------

    private void IterateCollections(GameObj manager)
    {
        // GameList -- wraps IL2CPP List<T>
        var unitList = new GameList(manager.ReadObj("Units"));
        _log.Msg($"Unit count: {unitList.Count}");
        for (int i = 0; i < unitList.Count; i++)
        {
            GameObj unit = unitList[i];
            _log.Msg($"  Unit {i}: {unit.GetName()}");
        }

        // foreach also works
        foreach (var unit in unitList)
        {
            _log.Msg($"  Unit: {unit.GetName()}");
        }

        // GameDict -- wraps IL2CPP Dictionary<K,V>
        var inventory = new GameDict(manager.ReadObj("Inventory"));
        foreach (var (key, value) in inventory)
        {
            _log.Msg($"  {key.GetName()} -> {value.ReadInt("Count")}");
        }

        // GameArray -- wraps IL2CPP native arrays
        var slots = new GameArray(manager.ReadPtr("Slots"));
        for (int i = 0; i < slots.Length; i++)
        {
            _log.Msg($"  Slot {i}: {slots[i].GetName()}");
        }
    }

    // ---------------------------------------------------------------
    // Patching methods with GamePatch
    // ---------------------------------------------------------------

    private void ApplyPatches()
    {
        // Postfix patch by type name and method name.
        // GamePatch resolves the type in Assembly-CSharp and applies the
        // Harmony patch. Returns false on failure instead of throwing.
        bool ok = GamePatch.Postfix(
            _harmony,
            "WeaponTemplate",                           // target type name
            "GetDamage",                                 // target method name
            typeof(MyModPlugin).GetMethod(
                nameof(Patch_GetDamage_Postfix),
                BindingFlags.Static | BindingFlags.NonPublic)
        );

        if (ok)
            _log.Msg("Patched WeaponTemplate.GetDamage");
        else
            _log.Warning("Failed to patch WeaponTemplate.GetDamage");

        // Prefix patch -- can use GameType instead of a string
        var agentType = GameType.Find("Agent");
        if (agentType.IsValid)
        {
            GamePatch.Prefix(
                _harmony,
                agentType,
                "TakeDamage",
                typeof(MyModPlugin).GetMethod(
                    nameof(Patch_TakeDamage_Prefix),
                    BindingFlags.Static | BindingFlags.NonPublic)
            );
        }
    }

    // Harmony patch methods must be static
    private static void Patch_GetDamage_Postfix(ref int __result)
    {
        // Double all weapon damage
        __result *= 2;
    }

    private static bool Patch_TakeDamage_Prefix()
    {
        // Returning false skips the original method (god mode)
        return true;
    }

    // ---------------------------------------------------------------
    // Modifying templates with Templates.WriteField
    // ---------------------------------------------------------------

    private void ModifyTemplates()
    {
        // Find a specific template instance
        var shotgun = Templates.Find("WeaponTemplate", "Shotgun");
        if (shotgun.IsNull)
        {
            _log.Warning("Shotgun template not found");
            return;
        }

        // Write a single field via managed reflection.
        // Supports dotted paths for nested properties.
        Templates.WriteField(shotgun, "Damage", 50);
        Templates.WriteField(shotgun, "Range", 8.5f);
        Templates.WriteField(shotgun, "Stats.CritChance", 0.25f);

        // Read back to verify
        var damage = Templates.ReadField(shotgun, "Damage");
        _log.Msg($"Shotgun Damage after patch: {damage}");

        // Batch-write multiple fields at once
        Templates.WriteFields(shotgun, new()
        {
            ["Damage"]   = 50,
            ["Range"]    = 8.5f,
            ["Accuracy"] = 0.7f
        });

        // Clone a template to create a new variant
        var customShotgun = Templates.Clone(
            "WeaponTemplate",
            "Shotgun",          // source instance name
            "Shotgun_Heavy"     // new instance name
        );
        if (!customShotgun.IsNull)
        {
            Templates.WriteField(customShotgun, "Damage", 80);
            _log.Msg("Created Shotgun_Heavy template");
        }
    }

    // ---------------------------------------------------------------
    // Debug output with DevConsole.Watch
    // ---------------------------------------------------------------

    private void SetupWatches()
    {
        // Watch expressions update every frame while the console is open.
        // Press ~ to toggle the console, then select the Watch tab.

        DevConsole.Watch("Scene", () => GameState.CurrentScene);

        DevConsole.Watch("Weapon Count", () =>
        {
            var weapons = GameQuery.FindAllCached(GameType.Find("WeaponTemplate"));
            return weapons.Length.ToString();
        });

        DevConsole.Watch("Shotgun Damage", () =>
        {
            var shotgun = Templates.Find("WeaponTemplate", "Shotgun");
            if (shotgun.IsNull) return "N/A";
            var dmg = Templates.ReadField(shotgun, "Damage");
            return dmg?.ToString() ?? "null";
        });

        // Log a one-off message to the console Log panel
        DevConsole.Log("MyMod watches registered");
    }
}
```

---

## Build

```bash
dotnet build -c Release
```

The output DLL will be at `bin/Release/net6.0/MyMod.dll`.

---

## Deploy

1. Create the modpack folder structure in the game's `Mods/` directory:

```
<GameRoot>/Mods/MyMod-modpack/
  modpack.json
  dlls/
    MyMod.dll
```

2. Copy your built DLL:

```bash
cp bin/Release/net6.0/MyMod.dll "<GameRoot>/Mods/MyMod-modpack/dlls/"
```

3. Launch the game. MelonLoader loads `Menace.ModpackLoader.dll`, which scans
   `Mods/*/modpack.json`, finds your modpack, loads `MyMod.dll` from the
   `dlls/` directory, discovers `MyModPlugin` (because it implements
   `IModpackPlugin`), and calls `OnInitialize` with a logger and Harmony
   instance.

4. Check the MelonLoader console or `MelonLoader/Latest.log` for your mod's
   output. Press **~** in-game to open the developer console.

---

## Plugin Lifecycle

The loader calls your plugin methods in this order:

| Method | When | Notes |
|--------|------|-------|
| `OnInitialize(logger, harmony)` | Once, after DLL load | Store the logger and harmony instance. Do not query game objects here -- the game assembly may not be fully initialized. |
| `OnSceneLoaded(buildIndex, sceneName)` | Every Unity scene load | Safe to query objects, apply patches, and modify templates. Called for every scene transition. |
| `OnUpdate()` | Every frame | Optional. Default is a no-op. Use for per-frame input polling or continuous logic. |
| `OnGUI()` | Every frame (IMGUI pass) | Optional. Default is a no-op. Use for drawing custom IMGUI overlays. |
| `OnUnload()` | Shutdown or hot-reload | Optional. Clean up resources, unpatch Harmony, remove watches. |

All lifecycle methods are wrapped in try/catch by the loader. If your method
throws, the exception is logged and the game continues.

---

## Data-Driven Patches (No Code Required)

For simple field overrides, you do not need a plugin DLL at all. The
`patches` section of `modpack.json` applies field modifications directly:

```json
{
  "manifestVersion": 2,
  "name": "ShotgunBuff",
  "version": "1.0.0",
  "author": "YourName",
  "loadOrder": 100,
  "patches": {
    "WeaponTemplate": {
      "Shotgun": {
        "Damage": 50,
        "Range": 8.5,
        "Accuracy": 0.7
      },
      "AssaultRifle": {
        "Damage": 30
      }
    }
  },
  "assets": {},
  "securityStatus": "SourceVerified"
}
```

The structure is `patches -> TypeName -> InstanceName -> FieldName -> Value`.
The loader finds all live instances of each type, matches by Unity object name,
and writes each field via managed reflection. Patches are retried across scene
loads until all template types are successfully resolved.

---

## Using GameState for Deferred Execution

Some game systems are not ready immediately when a scene loads. Use
`GameState.RunDelayed` and `GameState.RunWhen` to schedule work:

```csharp
public void OnSceneLoaded(int buildIndex, string sceneName)
{
    // Run 60 frames after scene load
    GameState.RunDelayed(60, () =>
    {
        var managers = GameQuery.FindAll("GameManager");
        _log.Msg($"GameManagers found: {managers.Length}");
    });

    // Run when a condition becomes true (polls once per frame, max 120 attempts)
    GameState.RunWhen(
        () => GameQuery.FindAll("TacticalState").Length > 0,
        () => _log.Msg("Tactical state is now available"),
        maxAttempts: 120
    );
}

// Or subscribe to the TacticalReady event (fires 30 frames after the
// tactical scene loads):
// GameState.TacticalReady += () => { ... };
```

---

## Error Handling

If something goes wrong in your plugin, use `ModError` to report it:

```csharp
try
{
    // risky operation
}
catch (Exception ex)
{
    ModError.Report("MyMod", "Failed to initialize weapons", ex);
}
```

Errors appear in the DevConsole Errors panel and in MelonLoader's log.
Severity levels: `Info`, `Warning`, `Error`, `Fatal`.

For quick status messages visible in the log panel:

```csharp
ModError.Info("MyMod", "Loaded 42 weapon templates");
ModError.Warn("MyMod", "Shotgun template not found, skipping buff");
```

---

## Next Steps

- See the [SDK API Reference](api/) for detailed documentation on each type.
- Browse the `examples/` directory in the repository for complete working
  modpacks including `DevMode-modpack` (entity spawner, god mode, delete tool)
  and `PinningMod-modpack` (Harmony prefix patches for balance tweaks).
- Use the REPL (press **~**, select the **REPL** tab) to experiment with SDK
  calls interactively before committing them to code.
